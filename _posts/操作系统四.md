---
layout: mypost
title: 基于内核栈切换的进程切换
categories: [Linux,面试]
---

### 实验内容


编写汇编程序 switch_to：  
完成主体框架；  
在主体框架下依次完成 PCB 切换、内核栈切换、LDT 切换等；  
修改 fork()，由于是基于内核栈的切换，所以进程需要创建出能完成内核栈切换的样子。  
修改 PCB，即 task_struct 结构，增加相应的内容域，同时处理由于修改了 task_struct 所造成的影响。  
用修改后的 Linux 0.11 仍然可以启动、可以正常使用。  
（选做）分析实验 3 的日志体会修改前后系统运行的差别。  

回答下面三个问题：

问题 1
针对下面的代码片段：
```bash
movl tss,%ecx
addl $4096,%ebx
movl %ebx,ESP0(%ecx)
```
回答问题：

（1）为什么要加 4096；
（2）为什么没有设置 tss 中的 ss0。  

问题 2
针对代码片段：
```bash
*(--krnstack) = ebp;
*(--krnstack) = ecx;
*(--krnstack) = ebx;
*(--krnstack) = 0;
```

回答问题：

（1）子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？  
（2）这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？  
（3）这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？

问题 3
为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？


kernel/sched.c

kernel/system_call.s

kernel/fork.c

include/linux/sched.h

![zip](os.zip)
