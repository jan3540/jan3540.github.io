---
layout: mypost
title: 操作系统（二）系统调用
categories: [Linux,操作系统]
---


## 操作系统（二）系统调用


在准备学习李治军老师的操作系统的时候，实验二的系统调用实验网上虽然有很多，但是有不少存在错误、步骤比较跳的的帖子，以及绝大多数都是实验过程中夹杂着很多理论，本文主要是将过程整合起来，没有过多的理论，以便同学们直接对着步骤完成实验再与理论结合起来。

总得来说有以下添加和修改的文件
1.添加3个文件: kernel/who.c; iam.c; whoami.c
2.修改: include/unistd.h; include/linux/sys.h  /kernel/system_call.s; kernel/Makefile

### 实现过程

修改unistd.h

![image](1.1.png)

```bash
#define __NR_whiami     72
#define __NR_iam        73
```



修改sys.h

![image-20240908145800074](1.2.png)

```bash
extern int sys_whoami();
extern int sys_iam();

# 注意顺序要相同
...,sys_whoami,sys_iam };
```



修改system_call.s



![image-20240908145840867](1.3.png)

```bash
nr_system_calls = 74
```



修改Makefile

![image-20240908145641168](1.4.png)

![image-20240908145708004](1.5.png)

```bash
OBJS  = sched.o system_call.o traps.o asm.o fork.o \
        panic.o printk.o vsprintf.o sys.o exit.o \
        signal.o mktime.o who.o

### Dependencies:
who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h
```

---

添加以下文件

who.c

```bash
/* 功能：核心态文件，在who.c里实现系统调用sys_iam()与sys_whoami() */
    
#include<errno.h>         /* linux-0.11/include */
#include<unistd.h>
#include<asm/segment.h>  /* linux-0.11/include/asm */
#include<linux/kernel.h>
/* 直接包含的头文件是到linux-0.11/include目录 */

#define MAXLEN 23
char username[MAXLEN+1] = {0};        /* 内核态下，存储名字 */

int sys_iam(const char* myname){   /* myname为_syscallx调用时保存好了的 */

	printk("sys_iam run......\n");
	unsigned int i = 0;
	unsigned int namelen = 0;

	/* get_fs_byte(const char * addr) 从用户空间逻辑地址addr取出一个字节数据 */
	while(get_fs_byte(myname+namelen)!='\0')
		++namelen;                          
	if(namelen > MAXLEN){
		errno = EINVAL;    /* #define EINVAL  22 : Invalid argument */   
		return -EINVAL;
	}
	printk("namelen:%d\n",namelen);  /* 核心态，用printk() */
	while(i < namelen){
		username[i] = get_fs_byte(myname+i);  /* 将用户态下传递的字符串参数拷贝到内核中保存 */
		++i;
	}
	username[i] = '\0';
	printk("username: %s\n",username);
	return namelen;
}

int sys_whoami(char* myname, unsigned int size){

	printk("sys_whoami run......\n");
	unsigned int i = 0;
	unsigned int namelen = 0;
	while(username[namelen]!='\0')
		++namelen;
	if(size < namelen){   /* size小于所需的拷贝空间 */
		errno = EINVAL;
		return -EINVAL;
	}
	for(; i <= namelen; ++i){
		put_fs_byte(username[i], myname+i); /* 将内核态里的数据拷贝到用户态文件里 */
	}
	printk("namelen: %d\n",namelen);
	return namelen;
}

```

iam.c

```bash
/* iam.c */
#define __LIBRARY__
#include <unistd.h> 
#include <errno.h>
#include <asm/segment.h> 
#include <linux/kernel.h>
_syscall1(int, iam, const char*, name);
   
int main(int argc, char *argv[])
{
    /*调用系统调用iam()*/
    iam(argv[1]);
    return 0;
}
```

whoami.c

```bash
#define __LIBRARY__
#include <unistd.h> 
#include <errno.h>
#include <asm/segment.h> 
#include <linux/kernel.h>
#include <stdio.h>
   
_syscall2(int, whoami,char *,name,unsigned int,size);
   
int main(int argc, char *argv[])
{
    char username[64] = {0};
    /*调用系统调用whoami()*/
    whoami(username, 24);
    printf("%s\n", username);
    return 0;
}
```

准备工作完成，准备编译

```bash
cd /path/oslab/linux-0.11
make clean
make all
#确保最后出现sync
```

![image-20240908151816737](1.6.png)



```bash
cd /path/oslab
./mount-dhc
cp iam.c whoiam.c hdc/usr/root
vi hdc/usr/include/unistd.h
#任意处添加这两条

#define __NR_whoami 72 
#define __NR_iam 73


cd /path/oslab
./run
#进入到Bochs
gcc -o whoiam whoiam.c
gcc -o iam iam.c
./iam jjt
./whoiam
```





![image-20240908144304720](1.7.png)

实验完成



<p align="right">作于2024年09月08日</p>